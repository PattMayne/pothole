# Copyright Â© Louie Quartz 2022
# Licensed under AGPL version 3 or later
#
# data.nim  ;;  Functions for handling Pothole-specific data types.
# The actual data types are stored in lib.nim

# From Pothole
import lib
import crypto

# From Nim's standard library
import std/strutils



# User data type, which represents actual users in the database.
# Note: Most of these are escaped using strutils.escape()
# You can use strutils.unescape() to remove that effect
# But make sure to escape them again.
#
# The following are made safe like so:
# id: plain, generated by std/oids
# handle: checked against unsafeHandleChars, escaped and toLowerAscii()
# name: If it doesn't exist then it's taken from handle. escaped.
# email: checked against unsafeHandleChars, escaped and toLowerAscii()
# bio: escaped()
# password: escaped()
# salt: plain, generated by std/oids
#
# -    id: string     =   An OID that represents the actual user (Db: blob primary key)
# -    handle: string =   A string containing the user's actual username (Db: varchar unique not null)
# -    name: string   =   A string containing the user's display name (Db: varchar)
# -    local: bool    =   A boolean indicating if this user is from this instance (Db: boolean)
# -    email: string  =   A string containing the user's email (Db: varchar)
# -    bio: string    =   A string containing the user's biography (Db: varchar)
# -    salt: string   =   The actual salt with which to hash the password. (Db: varchar not null)
# -    password:string=   A string to store a hashed + salted password (Db: varchar not null)

# Post data type, which represents posts in the database.
# -    id: string      =    A OID that represents the actual post (Db: blob primary key)
# -    sender: string  =    A string containing the sender of the post (Db: varchar not null)
# -    written: string =    A timestamp of when the post was written (Db: timestamp not null)
# -    updated: string =    A timestamp of when the post was updated (or null if it wasn't) (Db: timestamp)
# -    post: string    =    Actual JSON Data for the post (Db: varchar)
# - recipients:seq[str]=    A sequence of recipients (Db: varchar)

# Various helper procedures related to Users and Posts
# db.nim contains the actual user-creation procedures

# A function to create a new user from a handle and password
# This user is not validated or escaped.
proc newUser*(handle,password: string, local:bool): User =
  if isEmptyOrWhitespace(handle):
    error("Missing critical fields!\nProvided: " & handle & ", " & password)
  var newuser: User;

  # Create password and hash ONLY if user is local
  if local == true:
    for x in localInvalidHandle:
      newuser.handle = newuser.handle.replace($x,"")
    newuser.local = true
  else:
    newuser.local = false
  
  # Every User in our database will have an ID.
  newuser.id = randomString() # the 16 character default is good enough for IDs
  if local: 
    newuser.salt = randomString(16) # 32 characters is double what NIST recommends for salt lengths.
    newuser.password = hash(password, newuser.salt, 160000) # 120000 is what NIST recommends, but let's go a bit overboard.
    
  newuser.handle = handle
  
  return newuser

# A function remove any unsafe characters
proc safeifyHandle(handle: string): string =
  var newhandle = handle;
  var i: int = len(newhandle) - 1
  for x in 0 .. i:
    if newhandle[x] in unsafeHandleChars:
      newhandle = newhandle.replace($newhandle[x],"")
      i = len(newhandle) - 1
  return newhandle

# The fillEverything boolean tells us whether or not
# we should add everything ourselves or just leave it empty
# This procedure validates every field and makes it ready for
# transfer to database. Make sure to unescape.
proc escapeUser*(olduser: User): User =
  # Basic validation
  # We only need handle and password, the rest can be guessed.
  if isEmptyOrWhitespace(olduser.handle) or isEmptyOrWhitespace(olduser.password):
    error("Missing required fields for adding users\nUser: " & $olduser,"data.escapeUser")
  
  # Now let's add the info
  var newuser: User;

  # First, we loop over unsafeHandleChars and remove any characters that were found
  # Then we escape it, and turn it to lower-case ASCII
  newuser.handle = escape(safeifyHandle(toLowerAscii(olduser.handle)),"","")
  
  # Now let's do the display name.
  if isEmptyOrWhitespace(olduser.name):
    newuser.name = newuser.handle
  else:
    newuser.name = olduser.name.replace($'\\',"")
    newuser.name = escape(newuser.name,"","")

  # Now email.
  # We can use the same thing as we did with handle
  if isEmptyOrWhitespace(olduser.email):
    newuser.email = ""
  else:
    # First, we loop over unsafeHandleChars and remove any characters that were found
    # Then we escape it, and turn it to lower-case ASCII
    newuser.email = safeifyHandle(toLowerAscii(olduser.email))

  newuser.local = olduser.local

  # Bio.
  if isEmptyOrWhitespace(olduser.bio):
    newuser.bio = ""
  else:
    newuser.bio = escape(olduser.bio,"","")
   
  # Store password & salt but escape it first.
  newuser.password = escape(olduser.password,"","")
  newuser.salt = escape(olduser.salt,"","")

  return newuser
    
# A procedure to unescape/revert most changes
# made by escapeUser()
proc unescapeUser*(olduser: User): User =
  var newuser: User;
  if isEmptyOrWhitespace(olduser.handle) or isEmptyOrWhitespace(olduser.id):
    error("Faulty user provided. \nUser: " & $olduser, "data.unescapeUser")
  newuser.id = olduser.id
  newuser.handle = unescape(olduser.handle)
  newuser.name = unescape(olduser.name)
  newuser.email = unescape(olduser.email)
  newuser.local = olduser.local
  newuser.bio = unescape(olduser.bio)
  newuser.password = unescape(olduser.password)
  newuser.salt = unescape(olduser.salt)
  return newuser

# Basically escapeUser() without all the 
# escaping.