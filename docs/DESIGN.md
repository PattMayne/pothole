# Design choices

This is my personal development journal of Pothole. I describe the things and choices I take so that in the future I or other people will understand why they were added, how they work and when they were added.
I wanna try to make Pothole as light as possible. This means:

1. Reducing dependencies whenever possible.
2. Emphasizing readability over efficiency*
3. *: Readable code is often the most efficient code.

So here are the things I decided.

## Using Nim as a programming language.

Nim is an amazing language, I love the syntax so much! and I also love how fast it is, I tried this with Julia before but Julia is not fit for this task, it does not compile down to a binary without some workarounds and experimental plugins, which I do not like.

I also just love the documentation, the standard library is amazing, it has so many features.

Overall, the language is fun, safe and just plain awesome! It's like Python syntactically but more like C in terms of what you can do with it. 

## A custom config language instead of TOML.

*Note:* In the very early days of the project, I created a custom config parser but I switched to std/parsecfg. So to reflect this, this section has been removed and no longer applies.

### Make sure every request to config data is double-checked

So let me try to paint a scenario for you, which one is worse? Let's say you want to retrieve "PortNum" from the config file and so you send a request like-so:

```nim
var portnum:int = conf.getInt("PortNum")

web.startServer(app, portnum)
```

The program runs fine on your machine but complains on the other ones, it crashes! But what gives? Well it turns out "PortNum" is missing on some configuration. It's way easier for you as a developer to double-check that it exists first like so:

```nim
var portnum: Port;

if conf.exists("PortNum"):
    portnum = Port(parseInt(conf.get("PortNum")))
else:
    portnum = Port(3500)

web.startServer(app, portnum)
```

I know it looks and sounds inefficient but this would be way easier than having to constantly debug missing things. if what you are implementing uses an optional configuration parameter then make sure to double-check it or Error out in peace!

Required options do not have to be double-checked, if they are not there then just crash and let the user deal with it! It's their fault after all...

### Parse keys/options as lowercase by default.

I don't think it makes sense to distinguish "PORT", "Port" and "port" in the configuration file, the configuration parser should ideally lowercase all values when adding them to `configTable` so that programs don't worry about if they are spelling it right.

## Startup routine

When you run Pothole, it will search for a config file to parse. The first thing it looks for is the `POTHOLE_CONFIG` environment variable which should specify a location to the config file that Pothole is supposed to run.

The second thing Pothole looks for is the `--config=` command-line option, you can specify a configuration file here too.

It falls back to searching for a file named `pothole.conf` in the current working directory.

Yada yada, at the end of the entire startup routine it should start a webserver at 3500 or a port specified in the config file, this means Pothole won't need root permissions but it also has to be proxied behind a much more powerful and stable web server (Nginx, Caddy etc.)

This approach is more secure.

## Database stuff

This section is all about the database, ie. what tables exist, their purpose and how they are formatted. Yada yada.

I am not trying to add ActivityPub support *yet* but I am trying to experiment with a small-scale social network app.

For now, I will be experimenting with sqlite databases, it's important to note that sqlite is quite different. See sqlite adaptations section.

*Note:* These SQL tables can maybe get a bit out of date. So please refer to `docs/db.sql` instead of this section for information about databases in Pothole! :)

To store users, we will need a separate table with the following columns:

```sql
CREATE TABLE IF NOT EXISTS users (
  id BLOB PRIMARY KEY, -- A randomly-generated ID.
  handle VARCHAR(65535) UNIQUE NOT NULL, -- User's actual username
  name VARCHAR(65535) NOT NULL, -- User's display name
  local BOOLEAN NOT NULL, -- A boolean indicating if the user is from here or from somewhere else.
  email VARCHAR(255), -- To store the user's email
  bio VARCHAR(65535), -- To store the user's biography
  password VARCHAR(65535), -- Stores a password hash, the hash is generated by crypto.hash() which is based on nimcrypto's PBKDF2 implementation
  salt VARCHAR(65535), -- A password salt, generated by data.newUser().
  is_frozen BOOLEAN, -- Indicates if a user is banned. This prevents them from logging in.
);
```

Meanwhile to store posts, we will need a separate table with the following columns:

```sql
CREATE TABLE IF NOT EXISTS posts (
  id BLOB PRIMARY KEY,
  sender VARCHAR(65535) NOT NULL,
  written TIMESTAMP NOT NULL,
  updated TIMESTAMP,
  recipients VARCHAR(65535),
  post VARCHAR(65535) NOT NULL
);
```

### Sqlite adaptations

Sqlite is quite different from MariaDB or PostgreSQL, for one, it does not care about text length. We can store a very long post in a varchar and sqlite does not care if it exceeds that length.

There is also no UUID datatype, we have to add it in as a string or blob (I chose blob)

What about recipients? In Akkoma, recipients are implemented as an ARRAY in the database. But we don't have that with sqlite so we have to use strings again, we *could* re-purpose conf.parseArray()

conf.parseArray() is too slow for this purpose though, since it was designed for an entirely different form of data. 
We could store recipients like so: `bob@bob.thebuilder,alice@alice.wonderland` since commas *cannot* be in domain names or usernames and then use strutils.split() to split the commas into a sequence that can be evaluated.

## Considerations for this project

I have to go soon but I wanted to write a bit about what I want this project to be, so that I do not lose track of myself. First and foremost, I want pothole to be a lightweight ActivityPub backend, I want to get as close to minimalism and speed as I can and then I want to turn Pothole into a customization heaven, what do I mean by that? Well I mean, something like Tumblr, where each user can design their own "blog" with real HTML and CSS, that sounds exciting to me!

Tumblr is going to implement ActivityPub support but most instances are probably going to block them considering how huge they are (hundreds upon hundreds of times bigger than mastodon.social and mastodon.social is already blocked by a huge portion of the Fediverse) so I wanted to re-create Tumblr but in a much easier-to-deploy form and way lighter form that actually lasts!

If this succeeds, then we will have a:
1. easy-to-deploy, lightweight, scalable CMS
2. with support for multiple users
3. and where each user can design their own blog
4. with support for ActivityPub.

WHAT MORE COULD ANYONE POSSIBLY WANT! But that's in the future, now, I have to work to achieve the first stage which is a stable, reliable ActivityPub backend that consumes little resources. I will optimize it AS MUCH AS POSSIBLE, to get it as fast as possible and to use as little memory as possible. Minimal systems are reliable systems and reliable systems are secure systems.

## How blogs are stored.

"Blogs" are basically user themes.
Here is how they are stored in Pothole: `blogs[1]/user-id[2]/*.html[3]`

1. This is the blogs folder, which contains all blog files for all users. It can be configured in the configuration file (Folder section, Blog attribute), by default, Pothole will use "blogs/" if it's not in the config
2. This is the User ID. 
3. This is the actual blog directory, any files in it will be served as-is* except for 3 main files, all blogs must consist of these 3 files:
  3.1. index.html: This is our main user page, it will be displayed when a person goes to the external user profile, it's regular HTML with a bit of a custom syntax mixed in for displaying posts and user data.
  3.2. post.html: This is an individual post page, it will be used to display a single post individually or in a thread. It can also contain said custom syntax with *some* changes. Note: if we are displaying a thread then we would want to apply each user's theme on all posts whether they come from other users or from other servers.
  3.3 error.html: This is used when an error occurs, ie. if a post doesn't exist. It should only have one custom tag which is "$(USER_ERR)" (case-sensitive), that will be replaced with an error summary.


* For example, index.html can link a stylesheet at {{ $userdir }}/style.css which will be available at the user/static/style.css


## How themes are made.

User themes (index.html, post.html, error.html) are regular HTML files with a bit of custom syntax. This section describes *that* custom syntax.

All commands begin with `{{` and end with `}}`, commands can only process one bit at a time, piping is not supported sadly.

### {{ version = 1; }}

The very first thing you have to do is declare what specific version of this syntax you will be using. Things will change in the future and Pothole will try to support as many old versions as it can but eventually we will have to end support for something

I am currently defining version 1 in this document but note that it is not set-in-stone, as Pothole is developed, things might change without the version number reflecting that.

Until Pothole gets a stable release, do not expect this to actually matter much.

### Scopes

What you need to understand is that there are multiple "scopes", a scope is basically a list of variables, functions and whatnot that you as a user can use in your theming.

When you start out a command, you have the possibility of using one of three scopes:

1. post-scope: `#Item`, Examples: Beginning of Post: `#Summary`
2. user-scope: `.Item`, Examples: User bio: `.Summary`
3. instance-scope: `$ITEM` Examples: Instance description: `$Summary`

Scopes are inherited, which means that if you are fx. in a post block then your default scope will be the Post scope. If not then you move on to the User scope.

#### Post scope

The "Post" scope is the scope of an individual post, it allows you to retrieve the title of posts, content of posts, pictures and so on.

Note: This scope is only evaluted inside Post blocks or in `post.html`, if this scope is used outside of a post block, then an error will be raised.

Here is a list of attributes inside the Post scope you can use, anything else will cause an error and Pothole will show a blank page with the error summary:

1. `Summary`, string: The beginning of a post, typically the first sentence (Or technically, the first item in an array where the content of the post is split by periods)

2. `Title`, string: The title of a post, this might be null.

3. `Warning`, string: A content warning if its found, you can use `{{ #:Has = CW; }}`

4. `Attachment/Attachments`, sequence: Attachments in the picture. It's recommended to use forEach to list all attachments, like so: `{{ :ForEach(i) = Attachments; }} <img alt="{{ :get = i(alt) }}" src="{{ :get = i(src) }}"> {{ :End = ^;}} `

5. `Favorites`, integer: Number of Favorites/Likes/Thumbsups of the current post.

6. `Repeats`, integer: Number of Boosts/Repeats/Retoots of the current post.

7. `Content`, HTML: HTML of the post.

8. `WrittenIn`, A human-readable date of when the post was written. (Format: Month Day(st/nd/rd/th), Year. Hour:Minutes:Seconds) (Example: December 17th, 2022. 19:04:37) 

9. `UpdatedIn`, A human-readable date of when the post was updated. (Format: Month Day(st/nd/rd/th), Year. Hour:Minutes:Seconds) (Example: December 17th, 2022. 19:04:37) 

10. `WrittenAt`, A machine-readable date of when the post was written (Format: YYYY-MM-DD HH:MM:SS) (Example: 2022-12-17 19:04:37 = December 17th, 2022. 19:04:37)

11. `UpdatedAt`, A machine-readable date of when the post was updated. (Format: YYYY-MM-DD HH:MM:SS) (Example: 2022-12-17 19:04:37 = December 17th, 2022. 19:04:37)

12. `ReplyTo`, string: a string containing a url to the post that person is replying to.

13. `Replies`, sequence: A sequence of URLs that contain replies to the current post. 

14. `OP`, string: A string containing the username of the `ReplyTo` author

15. `Author`, string: A string containing the username of the current post author.

Functions:

The following are functions, 
Some functions can also have blocks or sections of code that do get executed. These can be ended
things that return true or false.

1. `Has`, function, 1: item: This function checks if an item exists or is not empty, it then parses a block (Which can be ended with ` {{ :End }})

2. `ForEach`, function, 1: sequence: A function that loops over a sequence of things. Like attachments and parses a block (Which can be ended with ` {{ :End }})

3. `DisplayGenActivity`, function, 0: A very generic function that just displays any Activity or Special object, like Polls or similar. The HTML is generated by Pothole and in most cases works fine with existing themes.

4. `IsReply`, function, 0: checks if a post is a reply and if it is then it parses the block inside. (Which can be ended with ` {{ :End }})

5. `End`, function, 1 (Optional): block: This functions marks the end of block, if no argument is provided then it ends the last-created block. 

6. `HowMany`, function 1: sequence: This function counts the number of items in any given sequence and returns it.

7. `Shorten`, function 1: string (Username): This function takes a username and shortens it.

8. `ExternalUser`, function 1: string (Username NOT SHORTENED): This function takes a username and generates a link to the external user profile.

9. `IsUpdated`, function 0: Checks if a post was updated, this is the same as `{{ :Has = UpdatedAt }}` 

#### User scope


#### Instance scope

## ActivityPub

### To parse the context, or to not parse the context.

The "context" is a very weird parameter in json, it's basically like a namespace (If you are an XHTML developer), it contains definitions for various terms. It's purpose is to help developers convert plain old JSON into something can be reliably-reproduced and something way easier to store.


I will give you two examples in favor of parsing the @context:

1. We can store activity data more efficiently, the plan for Pothole was to store Activity data and Object data as-is in the database which is a problem because JSON is huge and that is also a stupid idea. Pleroma & Akkoma already do this but it is stupid nontheless.

2. We maybe could detect false requests easier that way? We could detect software pretending to be ActivityPub compliant and software that actually is ActivityPub-compliant and deal with them separately. Note: this might increase the time needed to successfully receive an Activity and store by a lot.

And now I will give you two examples in favor of not parsing the @context:

1. Gotosocial had a bug where it struggled to federate with Friendica because a JSON-LD context (http://joinmastodon.org/ns) disappeared, this was joinmastodon's fault but it does prove my point. (GitHub issue: [mastodon/joinmastodon#i48](https://github.com/mastodon/joinmastodon/issues/148))

2. Not parsing the context and storing the JSON as-is would save us a lot of time from developing a parser for a special format that is not widely used. If anything, it's a pain how 

As of January 2nd, 2023, `curl`ing the ActivityStreams context definition with `Accept: application/json` returns this:

```
{
  "@context": {
    "@vocab": "_:",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "as": "https://www.w3.org/ns/activitystreams#",
    "ldp": "http://www.w3.org/ns/ldp#",
    "vcard": "http://www.w3.org/2006/vcard/ns#",
    "id": "@id",
    "type": "@type",
    "Accept": "as:Accept",
    "Activity": "as:Activity",
    "IntransitiveActivity": "as:IntransitiveActivity",
    "Add": "as:Add",
    "Announce": "as:Announce",
    "Application": "as:Application",
    "Arrive": "as:Arrive",
    "Article": "as:Article",
    "Audio": "as:Audio",
    "Block": "as:Block",
    "Collection": "as:Collection",
    "CollectionPage": "as:CollectionPage",
    "Relationship": "as:Relationship",
    "Create": "as:Create",
    "Delete": "as:Delete",
    "Dislike": "as:Dislike",
    "Document": "as:Document",
    "Event": "as:Event",
    "Follow": "as:Follow",
    "Flag": "as:Flag",
    "Group": "as:Group",
    "Ignore": "as:Ignore",
    "Image": "as:Image",
    "Invite": "as:Invite",
    "Join": "as:Join",
    "Leave": "as:Leave",
    "Like": "as:Like",
    "Link": "as:Link",
    "Mention": "as:Mention",
    "Note": "as:Note",
    "Object": "as:Object",
    "Offer": "as:Offer",
    "OrderedCollection": "as:OrderedCollection",
    "OrderedCollectionPage": "as:OrderedCollectionPage",
    "Organization": "as:Organization",
    "Page": "as:Page",
    "Person": "as:Person",
    "Place": "as:Place",
    "Profile": "as:Profile",
    "Question": "as:Question",
    "Reject": "as:Reject",
    "Remove": "as:Remove",
    "Service": "as:Service",
    "TentativeAccept": "as:TentativeAccept",
    "TentativeReject": "as:TentativeReject",
    "Tombstone": "as:Tombstone",
    "Undo": "as:Undo",
    "Update": "as:Update",
    "Video": "as:Video",
    "View": "as:View",
    "Listen": "as:Listen",
    "Read": "as:Read",
    "Move": "as:Move",
    "Travel": "as:Travel",
    "IsFollowing": "as:IsFollowing",
    "IsFollowedBy": "as:IsFollowedBy",
    "IsContact": "as:IsContact",
    "IsMember": "as:IsMember",
    "subject": {
      "@id": "as:subject",
      "@type": "@id"
    },
    "relationship": {
      "@id": "as:relationship",
      "@type": "@id"
    },
    "actor": {
      "@id": "as:actor",
      "@type": "@id"
    },
    "attributedTo": {
      "@id": "as:attributedTo",
      "@type": "@id"
    },
    "attachment": {
      "@id": "as:attachment",
      "@type": "@id"
    },
    "bcc": {
      "@id": "as:bcc",
      "@type": "@id"
    },
    "bto": {
      "@id": "as:bto",
      "@type": "@id"
    },
    "cc": {
      "@id": "as:cc",
      "@type": "@id"
    },
    "context": {
      "@id": "as:context",
      "@type": "@id"
    },
    "current": {
      "@id": "as:current",
      "@type": "@id"
    },
    "first": {
      "@id": "as:first",
      "@type": "@id"
    },
    "generator": {
      "@id": "as:generator",
      "@type": "@id"
    },
    "icon": {
      "@id": "as:icon",
      "@type": "@id"
    },
    "image": {
      "@id": "as:image",
      "@type": "@id"
    },
    "inReplyTo": {
      "@id": "as:inReplyTo",
      "@type": "@id"
    },
    "items": {
      "@id": "as:items",
      "@type": "@id"
    },
    "instrument": {
      "@id": "as:instrument",
      "@type": "@id"
    },
    "orderedItems": {
      "@id": "as:items",
      "@type": "@id",
      "@container": "@list"
    },
    "last": {
      "@id": "as:last",
      "@type": "@id"
    },
    "location": {
      "@id": "as:location",
      "@type": "@id"
    },
    "next": {
      "@id": "as:next",
      "@type": "@id"
    },
    "object": {
      "@id": "as:object",
      "@type": "@id"
    },
    "oneOf": {
      "@id": "as:oneOf",
      "@type": "@id"
    },
    "anyOf": {
      "@id": "as:anyOf",
      "@type": "@id"
    },
    "closed": {
      "@id": "as:closed",
      "@type": "xsd:dateTime"
    },
    "origin": {
      "@id": "as:origin",
      "@type": "@id"
    },
    "accuracy": {
      "@id": "as:accuracy",
      "@type": "xsd:float"
    },
    "prev": {
      "@id": "as:prev",
      "@type": "@id"
    },
    "preview": {
      "@id": "as:preview",
      "@type": "@id"
    },
    "replies": {
      "@id": "as:replies",
      "@type": "@id"
    },
    "result": {
      "@id": "as:result",
      "@type": "@id"
    },
    "audience": {
      "@id": "as:audience",
      "@type": "@id"
    },
    "partOf": {
      "@id": "as:partOf",
      "@type": "@id"
    },
    "tag": {
      "@id": "as:tag",
      "@type": "@id"
    },
    "target": {
      "@id": "as:target",
      "@type": "@id"
    },
    "to": {
      "@id": "as:to",
      "@type": "@id"
    },
    "url": {
      "@id": "as:url",
      "@type": "@id"
    },
    "altitude": {
      "@id": "as:altitude",
      "@type": "xsd:float"
    },
    "content": "as:content",
    "contentMap": {
      "@id": "as:content",
      "@container": "@language"
    },
    "name": "as:name",
    "nameMap": {
      "@id": "as:name",
      "@container": "@language"
    },
    "duration": {
      "@id": "as:duration",
      "@type": "xsd:duration"
    },
    "endTime": {
      "@id": "as:endTime",
      "@type": "xsd:dateTime"
    },
    "height": {
      "@id": "as:height",
      "@type": "xsd:nonNegativeInteger"
    },
    "href": {
      "@id": "as:href",
      "@type": "@id"
    },
    "hreflang": "as:hreflang",
    "latitude": {
      "@id": "as:latitude",
      "@type": "xsd:float"
    },
    "longitude": {
      "@id": "as:longitude",
      "@type": "xsd:float"
    },
    "mediaType": "as:mediaType",
    "published": {
      "@id": "as:published",
      "@type": "xsd:dateTime"
    },
    "radius": {
      "@id": "as:radius",
      "@type": "xsd:float"
    },
    "rel": "as:rel",
    "startIndex": {
      "@id": "as:startIndex",
      "@type": "xsd:nonNegativeInteger"
    },
    "startTime": {
      "@id": "as:startTime",
      "@type": "xsd:dateTime"
    },
    "summary": "as:summary",
    "summaryMap": {
      "@id": "as:summary",
      "@container": "@language"
    },
    "totalItems": {
      "@id": "as:totalItems",
      "@type": "xsd:nonNegativeInteger"
    },
    "units": "as:units",
    "updated": {
      "@id": "as:updated",
      "@type": "xsd:dateTime"
    },
    "width": {
      "@id": "as:width",
      "@type": "xsd:nonNegativeInteger"
    },
    "describes": {
      "@id": "as:describes",
      "@type": "@id"
    },
    "formerType": {
      "@id": "as:formerType",
      "@type": "@id"
    },
    "deleted": {
      "@id": "as:deleted",
      "@type": "xsd:dateTime"
    },
    "inbox": {
      "@id": "ldp:inbox",
      "@type": "@id"
    },
    "outbox": {
      "@id": "as:outbox",
      "@type": "@id"
    },
    "following": {
      "@id": "as:following",
      "@type": "@id"
    },
    "followers": {
      "@id": "as:followers",
      "@type": "@id"
    },
    "streams": {
      "@id": "as:streams",
      "@type": "@id"
    },
    "preferredUsername": "as:preferredUsername",
    "endpoints": {
      "@id": "as:endpoints",
      "@type": "@id"
    },
    "uploadMedia": {
      "@id": "as:uploadMedia",
      "@type": "@id"
    },
    "proxyUrl": {
      "@id": "as:proxyUrl",
      "@type": "@id"
    },
    "liked": {
      "@id": "as:liked",
      "@type": "@id"
    },
    "oauthAuthorizationEndpoint": {
      "@id": "as:oauthAuthorizationEndpoint",
      "@type": "@id"
    },
    "oauthTokenEndpoint": {
      "@id": "as:oauthTokenEndpoint",
      "@type": "@id"
    },
    "provideClientKey": {
      "@id": "as:provideClientKey",
      "@type": "@id"
    },
    "signClientKey": {
      "@id": "as:signClientKey",
      "@type": "@id"
    },
    "sharedInbox": {
      "@id": "as:sharedInbox",
      "@type": "@id"
    },
    "Public": {
      "@id": "as:Public",
      "@type": "@id"
    },
    "source": "as:source",
    "likes": {
      "@id": "as:likes",
      "@type": "@id"
    },
    "shares": {
      "@id": "as:shares",
      "@type": "@id"
    },
    "alsoKnownAs": {
      "@id": "as:alsoKnownAs",
      "@type": "@id"
    }
  }
}
```

Modern and old computers are definitely fast enough to parse this string everytime there's the need to store Activity data and we could also cache it or cache the result of it just to be sure. But I am still confused as to how we can transform JSON into an effective format for database storage or even how to use `@context` efficiently in the first-place! It's a mess!

What helped me understand `@context` a bit more is this quite from: [@a@pl.nulled.red](https://pl.nulled.red/users/a)

> context says "when i say actor i mean an ActivityStreams actor and not anything else like a movie actor". it defines type, structure, shape of data. and you can ensure that what you have is what you expect, instead of just assuming.

I want Pothole to be a reliable, efficient server and I think for it to be *that* reliable efficient server, I am gonna have to parse the `@context` and do *something* with it, even if its just validating the activity or storing the activity in a special storage-effective format.*

* Speaking of which: I kind of want to suggest something like a CSV with quotation! we could run strutils.escape() on the values of the activity we want to store so that there is no risk of SQL injections and we could easily strutils.unescape it!